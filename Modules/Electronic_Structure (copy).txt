import time

from . import Read
from . import AtomicBasis
from . import Symmetry
from . import Util
from . import Geometry
from .PhysConst import ConversionFactors
import numpy as np
from scipy.linalg import schur
from scipy.linalg import expm
from scipy.linalg import logm
from itertools import permutations
import matplotlib.pyplot as plt
import os
pathtocp2k=os.environ["cp2kpath"]
pathtobinaries=pathtocp2k+"/exe/local/"
def get_tensor_representation():
    """
    Constructs real-valued Cartesian tensor representations of the spherical harmonics
    for s, p, d, f, and g orbitals.

    Each orbital is expressed as a sum of monomials (x^i y^j z^k) with a known prefactor.
    These are then converted into symmetric tensors of rank:
        - 0 for s (scalar)
        - 1 for p (vector)
        - 2 for d (symmetric 3×3)
        - 3 for f (symmetric 3×3×3)
        - 4 for g (symmetric 3×3×3×3)

    The resulting tensors are **unnormalized**, consistent with the radial wavefunction
    later correcting normalization for full atomic orbitals.

    Returns:
        representation_matrices (dict): Maps each orbital label (e.g. 'd+1', 'f-2') to its
        corresponding tensor representation as a NumPy array.
    """
    # Dictionary mapping orbital labels to monomial expansions:
    # Each entry is a list of [exponent_vector, prefactor]
    cs={}
    # --- s orbital (scalar) ---
    cs['s']=[[[0,0,0],0.5/np.sqrt(np.pi)]]
    # --- p orbitals (vector) ---
    cs['py']=[[[0,1,0],np.sqrt(3./(4.0*np.pi))]]
    cs['pz']=[[[0,0,1],np.sqrt(3./(4.0*np.pi))]]
    cs['px']=[[[1,0,0],np.sqrt(3./(4.0*np.pi))]]
    # --- d orbitals (symmetric 3×3 tensors) ---
    cs['d-2']=[[[1,1,0],0.5*np.sqrt(15./np.pi)]]
    cs['d-1']=[[[0,1,1],0.5*np.sqrt(15./np.pi)]]
    cs['d0']=[[[2,0,0],-0.25*np.sqrt(5./np.pi)],[[0,2,0],-0.25*np.sqrt(5./np.pi)],[[0,0,2],0.5*np.sqrt(5./np.pi)]]
    cs['d+1']=[[[1,0,1],0.5*np.sqrt(15./np.pi)]]
    cs['d+2']=[[[2,0,0],0.25*np.sqrt(15./np.pi)],[[0,2,0],-0.25*np.sqrt(15./np.pi)]]
    # --- f orbitals (symmetric 3×3×3 tensors) ---
    cs['f-3']=[[[2,1,0],0.75*np.sqrt(35./2./np.pi)],[[0,3,0],-0.25*np.sqrt(35./2./np.pi)]]
    cs['f-2']=[[[1,1,1],0.5*np.sqrt(105./np.pi)]]
    cs['f-1']=[[[0,1,2],np.sqrt(21./2./np.pi)],[[2,1,0],-0.25*np.sqrt(21./2./np.pi)],[[0,3,0],-0.25*np.sqrt(21./2./np.pi)]]
    cs['f0']=[[[0,0,3],0.5*np.sqrt(7./np.pi)],[[2,0,1],-0.75*np.sqrt(7/np.pi)],[[0,2,1],-0.75*np.sqrt(7/np.pi)]]
    cs['f+1']=[[[1,0,2],np.sqrt(21./2./np.pi)],[[1,2,0],-0.25*np.sqrt(21./2./np.pi)],[[3,0,0],-0.25*np.sqrt(21./2./np.pi)]]
    cs['f+2']=[[[2,0,1],0.25*np.sqrt(105./np.pi)],[[0,2,1],-0.25*np.sqrt(105./np.pi)]]
    cs['f+3']=[[[3,0,0],0.25*np.sqrt(35./2./np.pi)],[[1,2,0],-0.75*np.sqrt(35./2./np.pi)]]
    # --- g orbitals (symmetric 3×3×3×3 tensors) ---
    cs['g-4']=[[[3,1,0],0.75*np.sqrt(35./np.pi)],[[1,3,0],-0.75*np.sqrt(35./np.pi)]] 
    cs['g-3']=[[[2,1,1],9.0*np.sqrt(35./(2*np.pi))/4.0],[[0,3,1],-0.75*np.sqrt(35./(2.*np.pi))]] 
    cs['g-2']=[[[1,1,2],18.0*np.sqrt(5./(np.pi))/4.0],[[3,1,0],-3.*np.sqrt(5./(np.pi))/4.0],[[1,3,0],-3.*np.sqrt(5./(np.pi))/4.0]] 
    cs['g-1']=[[[0,1,3],3.0*np.sqrt(5./(2*np.pi))],[[2,1,1],-9.0*np.sqrt(5./(2*np.pi))/4.0],[[0,3,1],-9.0*np.sqrt(5./(2*np.pi))/4.0]] 
    cs['g0']=[[[0,0,4],3.0*np.sqrt(1./(np.pi))/2.0],[[4,0,0],9.0*np.sqrt(1./(np.pi))/16.0],[[0,4,0],9.0*np.sqrt(1./(np.pi))/16.0],[[2,0,2],-9.0*np.sqrt(1./np.pi)/2.0],[[0,2,2],-9.0*np.sqrt(1./np.pi)/2.0],[[2,2,0],9.0*np.sqrt(1./np.pi)/8.0]]
    cs['g+1']=[[[1,0,3],3.0*np.sqrt(5./(2*np.pi))],[[1,2,1],-9.0*np.sqrt(5./(2*np.pi))/4.0],[[3,0,1],-9.0*np.sqrt(5./(2*np.pi))/4.0]]
    cs['g+2']=[[[2,0,2],18.0*np.sqrt(5./(np.pi))/8.0],[[0,2,2],-18.*np.sqrt(5./(np.pi))/8.0],[[0,4,0],3.*np.sqrt(5./(np.pi))/8.0],[[4,0,0],-3.*np.sqrt(5./(np.pi))/8.0]]
    cs['g+3']=[[[1,2,1],-9.0*np.sqrt(35./(2*np.pi))/4.0],[[3,0,1],0.75*np.sqrt(35./(2.*np.pi))]]
    cs['g+4']=[[[4,0,0],3.0*np.sqrt(35./np.pi)/16.0],[[2,2,0],-18.0*np.sqrt(35./np.pi)/16.0],[[0,4,0],3.0*np.sqrt(35./np.pi)/16.0]]
    # Map monomial powers to i,j tensor indices
    def add_monomial(M_lambda, monomial, type):
        """Adds a monomial to the tensor by symmetrizing over index permutations."""
        powers = monomial[0]
        factor = monomial[1]
        indices = [0]*powers[0] + [1]*powers[1] + [2]*powers[2]
        perms = set(permutations(indices))

        weight = factor / len(perms)
        for p in perms:
            if type == "d":
                M_lambda[p[0], p[1]] += weight
            elif type == "f":
                M_lambda[p[0], p[1], p[2]] += weight
            elif type == "g":
                M_lambda[p[0], p[1], p[2], p[3]] += weight
        return M_lambda
    # Assemble tensor representations
    representation_matrices = {}
    for lm in cs:
        if lm[0] == "s":
            representation_matrices[lm] = cs[lm][0][1]  # scalar
        elif lm[0] == "p":
            representation_matrices[lm] = cs[lm][0][1] * np.array(cs[lm][0][0]) # vector
        elif lm[0] == "d":
            mat = np.zeros((3, 3))
            for mono in cs[lm]:
                mat = add_monomial(mat, mono, type="d") 
            representation_matrices[lm] = mat # 3x3 matrix
        elif lm[0] == "f":
            ten3 = np.zeros((3, 3, 3))
            for mono in cs[lm]:
                ten3 = add_monomial(ten3, mono, type="f")
            representation_matrices[lm] = ten3 # 3x3x3 tensor
        elif lm[0] == "g":
            ten4 = np.zeros((3, 3, 3, 3))
            for mono in cs[lm]:
                ten4 = add_monomial(ten4, mono, type="g")
            representation_matrices[lm] = ten4 # 3x3x3x3 tensor

    return representation_matrices
def get_basis_transformation_matrices_l_block(O):
    def scalar_product(tensor1,tensor2):
        rank=len(np.shape(tensor1))
        if rank>0:
            ranklist=[it for it in range(rank)]
            return np.tensordot(tensor1,tensor2,axes=(ranklist,ranklist))
        else:
            return tensor1*tensor2
    def apply_O_matrix(O,tensor):
        rank=len(np.shape(tensor))
        if rank>0:
            ranklist=[it for it in range(rank)]
            for it in ranklist:
                tensor=np.tensordot(O,tensor,axes=(1,it))
            return tensor
        else:
            return tensor

    canonical_ordering={}
    canonical_ordering["s"]=["s"]
    canonical_ordering["p"]=["py","pz","px"]
    canonical_ordering["d"]=["d-2","d-1","d0","d+1","d+2"]
    canonical_ordering["f"]=["f-3","f-2","f-1","f0","f+1","f+2","f+3"]
    canonical_ordering["g"]=["g-4","g-3","g-2","g-1","g0","g+1","g+2","g+3","g+4"]


    representation_matrices=get_tensor_representation()
    transformation_matrices={}
    for l in ["s","p","d","f","g"]:
        transformation_matrix=np.zeros((len(canonical_ordering[l]),len(canonical_ordering[l])))
        for it1 in range(len(canonical_ordering[l])):
            for it2 in range(len(canonical_ordering[l])):
                B1=representation_matrices[canonical_ordering[l][it1]]
                B2=representation_matrices[canonical_ordering[l][it2]]
                O_B2=apply_O_matrix(O,B2)
                overlap=scalar_product(B1,O_B2)
                norm=scalar_product(B1,B1)
                transformation_matrix[it1][it2]=overlap/norm
        transformation_matrices[l]=transformation_matrix
    return transformation_matrices

def get_l_ordering(Basis):
    ordering={}
    for atom in Basis:
        ordering_atom=[]
        ordering_atom.append(Basis[atom][0][2][0])
        for it in range(1,len(Basis[atom])):
            if (Basis[atom][it][2][0]!=Basis[atom][it - 1][2][0] or Basis[atom][it][1]!=Basis[atom][it-1][1]) or Basis[atom][it][0]!=Basis[atom][it-1][0]:
                ordering_atom.append(Basis[atom][it][2][0])
        ordering[atom]=ordering_atom
    return ordering
def get_l_sizes(label):
    if label=="s":
        return 1
    elif label=="p":
        return 3
    elif label=="d":
        return 5
    elif label=="f":
        return 7
    elif label=="g":
        return 9
    else:
        ValueError("Higher labels not yet implemented")
def get_index_block_start(atom_index,atoms,l_ordering):
    start_index=0
    for idx,atom in enumerate(atoms):
        if idx<atom_index:
            for order in l_ordering[atom]:
                start_index+=get_l_sizes(order)
    return start_index
        
def get_basis_transformation(O,P,atoms,basis):
    basis_transformation_matrices_l_block=get_basis_transformation_matrices_l_block(O)
    l_ordering=get_l_ordering(basis)
    basis_size=0
    for atom in atoms:
        for order in l_ordering[atom]:
            basis_size+=get_l_sizes(order)
    basis_transformation=np.zeros((basis_size,basis_size))
    nonzero_indices = np.nonzero(P)
    for idx1, idx2 in zip(nonzero_indices[0], nonzero_indices[1]):
        start_index_1=get_index_block_start(idx1,atoms,l_ordering)
        start_index_2=get_index_block_start(idx2,atoms,l_ordering)
        for l in l_ordering[atoms[idx1]]:
            block=basis_transformation_matrices_l_block[l]
            basis_transformation[start_index_1:start_index_1+np.shape(block)[0],start_index_2:start_index_2+np.shape(block)[1]]=block
            start_index_1+=np.shape(block)[0]
            start_index_2+=np.shape(block)[1]
    return basis_transformation








        
class ElectronicStructure:
    def __init__(self, mol):
        print("    -> Initializing ElectronicStructure object...")
        # --- This is the Back-Reference ---
        # Store a reference to the parent MolecularStructure object. 
        if hasattr(mol, 'KS_Hamiltonian_alpha'):
            return
        self.mol_path=mol.path
        self.Basis=AtomicBasis.getBasis(mol.electronic_structure_path)
        num_e,charge=Read.get_number_of_electrons(parentfolder=mol.electronic_structure_path)
        self.num_e=num_e
        self.charge=charge
        self.multiplicity=Read.read_multiplicity(path=mol.electronic_structure_path)
        KS_alpha,KS_beta,OLM=Read.read_ks_matrices(mol.electronic_structure_path)
        self.UKS=Read.check_uks(mol.electronic_structure_path)
        self.KS_Hamiltonian_alpha=KS_alpha
        self.KS_Hamiltonian_beta=KS_beta
        self.OLM=OLM
        cond_number=np.linalg.cond(OLM)
        if cond_number>10**(6):
            Warning("Large Condition number of the Overlap Matrix! Cond(OLM)="+str(cond_number))
        self.inverse_sqrt_OLM=Util.LoewdinTransformation(OLM,algorithm='Schur-Pade')
        self.ElectronicEigenstates={}
        self.indexmap={}
        self.indexmap["alpha"]={}
        self.ElectronicEigenstates["alpha"]={}
        if self.UKS:
            self.indexmap["beta"]={}
            self.ElectronicEigenstates["beta"]={}
        # Attach method dynamically
        atoms=mol.atoms
        self.Electronic_Symmetry = Electronic_Symmetry(mol.Molecular_Symmetry,atoms,self.Basis)
        name=mol.name
        axes=mol.Geometric_UC_Principle_Axis
        self.getElectronicEigenstates(name,atoms,axes)

        
    def getElectronicEigenstates(self,name,atoms,axes):
        def TransformHamiltonian(self,atoms,axes):
            U=get_basis_transformation(np.array(axes).T,np.eye(len(atoms)),atoms,self.Basis)
            if self.UKS:
                KS_Hamiltonian_alpha=self.KS_Hamiltonian_alpha
                KS_Hamiltonian_beta=self.KS_Hamiltonian_beta
                KS_Hamiltonian_alpha=U.T@KS_Hamiltonian_alpha@U
                KS_Hamiltonian_beta=U.T@KS_Hamiltonian_beta@U
            else:
                KS_Hamiltonian_alpha=self.KS_Hamiltonian_alpha
                KS_Hamiltonian_alpha=U.T@KS_Hamiltonian_alpha@U
                KS_Hamiltonian_beta=KS_Hamiltonian_alpha
            return KS_Hamiltonian_alpha,KS_Hamiltonian_beta,U
        print(f"ℹ️ : Calculating electronic eigenstates for {name}")
        # --- Setup and Hessian Transformation ---
        KS_Hamiltonian_alpha,KS_Hamiltonian_beta,U=TransformHamiltonian(self,atoms,axes)
        sqrtSm1 = self.inverse_sqrt_OLM
        sqrtSm1=U.T@sqrtSm1@U
        KS_Hamiltonian_alpha_orth = np.real(sqrtSm1 @ KS_Hamiltonian_alpha @ sqrtSm1)
        if self.UKS:
            KS_Hamiltonian_beta_orth = sqrtSm1 @ KS_Hamiltonian_beta @ sqrtSm1
        
        
        # (Optional) Visualize the original mass-weighted Hessian
        plt.imshow(KS_Hamiltonian_alpha_orth, cmap='viridis', interpolation='nearest')
        plt.colorbar()
        plt.savefig("./Hamiltonian_alpha_orth_Original.png")
        plt.close()

        if self.UKS:
            # (Optional) Visualize the original mass-weighted Hessian
            plt.imshow(KS_Hamiltonian_beta_orth, cmap='viridis', interpolation='nearest')
            plt.colorbar()
            plt.savefig("./Hamiltonian_beta_orth_Original.png")
            plt.close()
        
        # --- CONSISTENT SYMMETRY ORDERING ---
        SymSectors = self.Electronic_Symmetry.SymSectors
        VIrr = self.Electronic_Symmetry.IrrepsProjector
        
        # 1. Sort symmetry labels alphabetically to ensure a consistent order.
        sorted_sym_labels = sorted(SymSectors.keys())
        
        # 2. Build the reordering array based on the sorted labels.
        # This groups basis functions by symmetry, in a fixed order.
        reordering = np.concatenate([SymSectors[key] for key in sorted_sym_labels])
        
        # 3. Reorder the projector matrix columns based on the sorted symmetry order.
        VIrr_reordered = VIrr[:, reordering]
        
        # 4. Create the block-diagonal Hessian. The blocks are now in a consistent order.
        KS_Hamiltonian_alpha_orth_Sectors = VIrr_reordered.T @ KS_Hamiltonian_alpha_orth @ VIrr_reordered
        if self.UKS:
            KS_Hamiltonian_beta_orth_Sectors = VIrr_reordered.T @ KS_Hamiltonian_beta_orth @ VIrr_reordered
        
        # (Optional) Visualize the block-diagonalized Hessian
        plt.imshow(KS_Hamiltonian_alpha_orth_Sectors, cmap='viridis', interpolation='nearest')
        plt.colorbar()
        plt.savefig("./Hamiltonian_alpha_orth_Sectors.png")
        plt.close()
        if self.UKS:
            plt.imshow(KS_Hamiltonian_alpha_orth_Sectors, cmap='viridis', interpolation='nearest')
            plt.colorbar()
            plt.savefig("./Hamiltonian_beta_orth_Sectors.png")
            plt.close()
        
        # --- BLOCK DIAGONALIZATION (IN CONSISTENT ORDER) ---
        print(f"ℹ️ : Symmetry Sectors and Electronic Energies")
        current_index = 0
        # 5. Iterate through the sorted labels to process each block.
        label_alpha=[]
        energy_alpha=[]
        if self.UKS:
            label_beta=[]
            energy_beta=[]
        for sym in sorted_sym_labels:
            block_size = len(SymSectors[sym])
            
            # Extract the symmetry block
            Block_Hamiltonian_alpha = KS_Hamiltonian_alpha_orth_Sectors[current_index : current_index + block_size,
                                                        current_index : current_index + block_size]
            if self.UKS:
                Block_Hamiltonian_beta = KS_Hamiltonian_beta_orth_Sectors[current_index : current_index + block_size,
                                                        current_index : current_index + block_size]
            
            # Diagonalize the block to get eigenvalues and eigenvectors for this symmetry
            eigenvalues_alpha, eigenvectors_alpha = np.linalg.eigh(Block_Hamiltonian_alpha)
            
            # Frequencies (cm^-1) are the signed square roots of the eigenvalues
            energies_alpha_eV = eigenvalues_alpha*27.211
            print(f"Symmetry Sector for Spin Species ↑: {sym}, Energies (eV): \n {energies_alpha_eV}")
            
            # Transform eigenvectors from the symmetry basis back to the mass-weighted basis
            V_mwh_alpha = U@VIrr_reordered[:, current_index : current_index + block_size] @ eigenvectors_alpha
            if self.UKS:
                 # Diagonalize the block to get eigenvalues and eigenvectors for this symmetry
                eigenvalues_beta, eigenvectors_beta = np.linalg.eigh(Block_Hamiltonian_beta)
                
                # Frequencies (cm^-1) are the signed square roots of the eigenvalues
                energies_beta_eV = eigenvalues_beta*27.211
                print(f"Symmetry Sector for Spin Species ↓: {sym}, Energies (eV): \n {energies_beta_eV}")
                
                # Transform eigenvectors from the symmetry basis back to the mass-weighted basis
                V_mwh_beta = U@VIrr_reordered[:, current_index : current_index + block_size] @ eigenvectors_beta
            
            # Store the calculated vibrational modes
            if sym not in self.ElectronicEigenstates["alpha"]:
                self.ElectronicEigenstates["alpha"][sym] = []
                if self.UKS:
                    self.ElectronicEigenstates["beta"][sym] = []


            for i in range(block_size):
                state = ElectronicState(A=V_mwh_alpha[:, i],a=self.inverse_sqrt_OLM@V_mwh_alpha[:, i],energy=eigenvalues_alpha[i],symmetry_label=sym,statelabel=(sym,i))
                self.ElectronicEigenstates["alpha"][sym].append(state)
                label_alpha.append((sym,i))
                energy_alpha.append(eigenvalues_alpha[i])
                if self.UKS:
                    state = ElectronicState(A=V_mwh_beta[:, i],a=self.inverse_sqrt_OLM@V_mwh_beta[:, i],energy=eigenvalues_beta[i],symmetry_label=sym,statelabel=(sym,i))
                    self.ElectronicEigenstates["beta"][sym].append(state)
                    label_beta.append((sym,i))
                    energy_beta.append(eigenvalues_beta[i])
            # Advance the index to the start of the next block
            current_index += block_size

        if not self.UKS:
            label_alpha.append((sym,i))
            print(eigenvalues_alpha[i])
            energy_alpha.append(eigenvalues_alpha[i])
            sorted_indices=np.argsort(energy_alpha)
            label_alpha=np.array(label_alpha)[sorted_indices]
            Homoindex=self.num_e/2
            for id,element in enumerate(label_alpha):
                self.indexmap["alpha"][int(id+1-Homoindex)]=element



def bloch_form(mol, path= './'):
    if 'Bloch_states.npy' in os.listdir(path):
        print('Found pre-calculated bloch states!')
        bloch_eigenstates = np.load('Bloch_states.npy')
    else:
        ksh = mol.electronic_structure.KS_Hamiltonian_alpha
        olm = mol.electronic_structure.OLM
        prim_gam_sym, non_prim_gam_sym = separating_symmetries(mol)
        bloch_eigenstates = []

        for sym_sector in non_prim_gam_sym:
            sym_states = []
            for state in mol.electronic_structure.ElectronicEigenstates["alpha"][sym_sector]:
                sym_states.append(state.a)
            sym_states = np.array(sym_states)

            periodic_bool = np.array(mol.periodicity) > 1
            full = sym_states @ ksh @ sym_states.T
            for d in [0, 1, 2]:
                if periodic_bool[d]:
                    T_op = mol.electronic_structure.Electronic_Symmetry.Symmetry_Generators['t' + str(d + 1)]
                    full += (sym_states @ olm @ T_op @ sym_states.T)
            val, vec = np.linalg.eig(full)
            bloch = sym_states.T @ vec

            for i in range(bloch.shape[1]):
                bloch_eigenstates.append(bloch[:, i])

        bloch_eigenstates = np.array(bloch_eigenstates)
        #np.save(path+'Bloch_states.npy', bloch_eigenstates)

    return bloch_eigenstates.T

def separating_symmetries(mol):
    import re
    # Figuring out the translational symmetries in the structure:
    periodic_bool = np.array(mol.periodicity) > 1
    periodic = periodic_bool.astype(int)

    # Isolating Symmetry sectors that correspond to the primitive gamma point
    symsecs = list(mol.electronic_structure.Electronic_Symmetry.SymSectors.keys())

    patternT = re.compile(r't(\d+)=([-+]?\d+)')
    prim_gam_sym = []
    for sym in symsecs:
        if 'Id=1' in sym:
            check = []
            for dir in patternT.findall(sym):
                if int(dir[1]) == 1:
                    check.append(True)
                else:
                    check.append(False)
            if all(check):
                prim_gam_sym.append(sym)

    non_prim_gam_sym = list(set(symsecs) - set(prim_gam_sym))
    return prim_gam_sym, non_prim_gam_sym


def cel_periodic_overlap_calc(mol, path='./'):
    import re
    pattern = re.compile(r'^OLM_cell_per[123]\.npy$')
    already_stored_flag = False
    for file in os.listdir(path):
        if pattern.match(file):
            already_stored_flag = True

    if already_stored_flag:
        print('Found already calculated and stored phases!')
        return None
    else:
        periodic_bool = np.array(mol.periodicity) > 1
        periodic = periodic_bool.astype(int)
        basis = mol.electronic_structure.Basis
        xyz_filepath = Read.get_xyz_filename(path)
        atoms = Read.read_atomic_coordinates(xyz_filepath)
        q_points, unit_vectors = get_q_points(mol)
        cellvectors = Geometry.getNeibouringCellVectors(cell=mol.cellvectors, m=periodic[0], n=periodic[1], l=periodic[2])
        # assuming the supercell is large enough so that just the first neighbouring cells are enough; otherwise a convergence check would be needed!
        for d in [0, 1, 2]:
            if periodic_bool[d]:
                print('Calculating ', str(d+1), 'th direction.')
                phase = AtomicBasis.get_phase_operators(atoms, basis, q_vector=unit_vectors[d], cell_vectors=cellvectors)
                np.save(path + 'OLM_cell_per' + str(d + 1) + '.npy', phase)
        return None

def recommended_kpath_bandstruc(mol):
    # K-path for bandstructure plot to check the working of band indexing
    # Written in CP2K input format for ease
    periodic_bool = np.array(mol.periodicity) > 1
    dimension = np.sum(periodic_bool.astype(int))
    edges = [np.array([0.500, 0.000, 0.000]), np.array([0.000, 0.500, 0.000]), np.array([0.000, 0.000, 0.500])]
    gamma = np.array([0.000, 0.000, 0.000])
    file = open('kpoint_set.txt', 'w')
    if dimension == 1:
        line = []
        line.append(-1 * edges[np.where(periodic_bool)[0][0]])
        line.append(gamma)
        line.append(edges[np.where(periodic_bool)[0][0]])

        for point in line:
            file.writelines('SPECIAL_POINT ' + str(point[0]) + ' ' + str(point[1]) + ' ' + str(point[2]) + '\n')

    elif dimension == 2:
        set1, set2, set3, set4 = [], [], [], []
        set1.append(-1 * edges[np.where(periodic_bool)[0][0]])
        set1.append(gamma)
        set1.append(edges[np.where(periodic_bool)[0][0]])

        set2.append(-1 * edges[np.where(periodic_bool)[0][1]])
        set2.append(gamma)
        set2.append(edges[np.where(periodic_bool)[0][1]])

        set3.append(-1 * edges[np.where(periodic_bool)[0][0]] - 1 * edges[np.where(periodic_bool)[0][1]])
        set3.append(gamma)
        set3.append(edges[np.where(periodic_bool)[0][0]] + edges[np.where(periodic_bool)[0][1]])

        set4.append(-1 * edges[np.where(periodic_bool)[0][0]] + edges[np.where(periodic_bool)[0][1]])
        set4.append(gamma)
        set4.append(edges[np.where(periodic_bool)[0][0]] - edges[np.where(periodic_bool)[0][1]])

        for set in [set1, set2, set3, set4]:
            file.writelines("&KPOINT_SET\n")
            file.writelines("  UNITS B_VECTOR\n")
            for point in set:
                file.writelines('  SPECIAL_POINT ' + str(point[0]) + ' ' + str(point[1]) + ' ' + str(point[2]) + '\n')
            file.writelines("NPOINTS 20\n")
            file.writelines("&END KPOINT_SET\n")

    elif dimension == 3:
        set1, set2, set3, set4, set5, set6, set7, set8, set9, set10, set11, set12, set13 = [], [], [], [], [], [], [], [], [], [], [], [], []

        set1 = [-1 * edges[0], gamma, edges[0]]
        set2 = [-1 * edges[1], gamma, edges[1]]
        set3 = [-1 * edges[2], gamma, edges[2]]

        set4 = [-1 * edges[0] - 1 * edges[1], gamma, edges[0] + edges[1]]
        set5 = [-1 * edges[1] - 1 * edges[2], gamma, edges[1] + edges[2]]
        set6 = [-1 * edges[0] - 1 * edges[2], gamma, edges[0] + edges[2]]

        set7 = [-1 * edges[0] + edges[1], gamma, edges[0] - edges[1]]
        set8 = [-1 * edges[1] + edges[2], gamma, edges[1] - edges[2]]
        set9 = [-1 * edges[0] + edges[2], gamma, edges[0] - edges[2]]

        set10 = [-1 * edges[0] - 1 * edges[1] - 1 * edges[2], gamma, edges[0] + edges[1] + edges[2]]
        set11 = [edges[0] - 1 * edges[1] - 1 * edges[2], gamma, - 1 * edges[0] + edges[1] + edges[2]]
        set12 = [-1 * edges[0] + edges[1] - 1 * edges[2], gamma, edges[0] - 1 * edges[1] + edges[2]]
        set13 = [-1 * edges[0] - 1 * edges[1] + edges[2], gamma, edges[0] + edges[1] - 1 * edges[2]]

        for set in [set1, set2, set3, set4, set5, set6, set7, set8, set9, set10, set11, set12, set13]:
            file.writelines("&KPOINT_SET\n")
            file.writelines("  UNITS B_VECTOR\n")
            for point in set:
                file.writelines('  SPECIAL_POINT ' + str(point[0]) + ' ' + str(point[1]) + ' ' + str(point[2]) + '\n')
            file.writelines("NPOINTS 20\n")
            file.writelines("&END KPOINT_SET\n")

    file.close()
    return None

def plot_bandstruc(mol, band_indexing_results, nh, nl, bsfilename,path='./'):
    import re
    file = open(path+bsfilename,'r')
    content = file.read()
    set_separator = f'\n# Set'
    sets_linewise = [part.rstrip().split('\n') for part in content.split(set_separator)]
    sets = content.split(set_separator)
    pattern = r"(\d+)\s+k-points.*?(\d+)\s+bands"
    point_separator = f'\n#  Point'
    special_k, kpoints_on_path, band_energies_on_path, occupations_on_path = [], [], [], []
    for num_set in range(len(sets)):
        points_in_line, num_of_bands = int(re.search(pattern, sets_linewise[num_set][0]).group(1)), int(re.search(pattern, sets_linewise[num_set][0]).group(2))
        special_k.append([np.array([sets_linewise[num_set][j].split()[i] for i in [4,5,6]]).astype(float) for j in [1,2,3]])
        del sets_linewise[num_set][:4]
        set_reduced = sets[num_set].split(point_separator,1)[1]
        points = [part.split('\n') for part in set_reduced.split(point_separator)]
        kpath=[]
        this_line_energies, this_line_occupations = np.zeros((points_in_line, num_of_bands)), np.zeros((points_in_line, num_of_bands))
        for point in range(points_in_line):
            kpath.append([np.array(points[point][0].split()[i]).astype(float) for i in [3,4,5]])
            del points[point][:2]
            for band in range(num_of_bands):
                this_line_energies[point,band], this_line_occupations[point,band] = float(points[point][band].split()[1]), float(points[point][band].split()[2])
        kpoints_on_path.append(kpath)
        band_energies_on_path.append(this_line_energies)
        occupations_on_path.append(this_line_occupations)
    file.close()

    cell_vectors = mol.cellvectors
    periodicity = mol.periodicity
    primitive_cell_vectors = [cell_vectors[i] / periodicity[i] for i in range(3)]
    reciprocal_lattice = np.zeros((3, 3))
    reciprocal_lattice[0,:], reciprocal_lattice[1,:], reciprocal_lattice[2,:] = get_reciprocal_lattice_vectors(*primitive_cell_vectors)
    conversion_factor = ConversionFactors["a.u.->A"]
    ksh = mol.electronic_structure.KS_Hamiltonian_alpha

    os.makedirs(path+'Testing_band_indexing',exist_ok=True)
    for band_ind, band in enumerate(band_indexing_results):
        os.makedirs(path + 'Testing_band_indexing/' + str(band_ind), exist_ok=True)
        for path_index,kpath in enumerate(special_k):

            direction_vector = (kpath[0]*conversion_factor @reciprocal_lattice ) - (kpath[-1]*conversion_factor @ reciprocal_lattice )
            occ_matrix = occupations_on_path[path_index]
            vb_index = np.where(occupations_on_path[path_index][0, :] < 0.95)[0][0] -1  # Assuming the Fermi level is in the gap and no partial occupations!
            e_fermi = np.max(band_energies_on_path[path_index][:, vb_index])
            k_dist = [0]
            k_dist.extend(np.cumsum(np.linalg.norm(np.diff( ((kpoints_on_path[path_index] @ reciprocal_lattice) *conversion_factor) ,axis=0), axis=1)))
            k_dist = np.array(k_dist)
            chosen_indices = [vb_index - (nh-1), vb_index + (nl+1)]
            chosen_dft_bands = band_energies_on_path[path_index][:,chosen_indices[0]:chosen_indices[1]]-e_fermi
            plt.figure()

            for dft_band_num in range(chosen_dft_bands.shape[1]):
                plt.plot(k_dist, chosen_dft_bands[:, dft_band_num], color='Blue')

            sampled_kpoints = list(band.keys())
            for kpoint in sampled_kpoints:
                if (np.round(np.cross(direction_vector,np.array(kpoint) - (kpath[0]*conversion_factor @reciprocal_lattice)),5) == np.array([0.,0.,0.])).all():
                    dist = np.linalg.norm(np.array(kpoint) - np.array(kpath[0]*conversion_factor @reciprocal_lattice))
                    state = band[kpoint]
                    ene = (np.real(np.conjugate(state.T) @ ksh @ state)*27.211) - e_fermi
                    plt.scatter(dist, ene)

            plt.axhline(y=0, color='gray', linestyle='--', linewidth=0.75)
            plt.xticks([0,k_dist[int(np.floor(float(k_dist.shape[0]*0.5)))],k_dist[int(k_dist.shape[0]-1)]],kpath)
            figname = path+'Testing_band_indexing/'+ str(band_ind) +'/' +str(path_index)+'.png'
            plt.savefig(figname, dpi=600)
            plt.close()

    return None

def band_index(mol, nh, nl, stored_phi=False, path='./'):
    from qpath import simple_qpath as find_qpath
    import time

    p_gamma_ind = []
    periodic_bool = np.array(mol.periodicity) > 1
    periodic = periodic_bool.astype(int)
    prim_gam_sym, non_prim_gam_sym = separating_symmetries(mol)

    # Isolating the states that correspond to the primitive gamma point

    estate_dict = mol.electronic_structure.indexmap['alpha']
    finalind = next(iter(estate_dict))
    occ_ind = -1 * np.arange(0, -1 * finalind + 1)

    occ_prim_gam_states = []
    if nh > 0:
        for ind in occ_ind:
            if estate_dict[ind][0] in prim_gam_sym:
                occ_prim_gam_states.append(estate_dict[ind])
                if len(occ_prim_gam_states) == nh:
                    break

    unocc_prim_gam_states = []
    if nl > 0:
        for ind in range(0, int(len(estate_dict) - np.shape(occ_ind)[0])):
            if estate_dict[ind][0] in prim_gam_sym:
                unocc_prim_gam_states.append(estate_dict[ind])
                if len(unocc_prim_gam_states) == nl:
                    break

    prim_gam_states = unocc_prim_gam_states + occ_prim_gam_states

    basis = mol.electronic_structure.Basis
    xyz_filepath = Read.get_xyz_filename(path)
    atoms = Read.read_atomic_coordinates(xyz_filepath)
    q_points, unit_vectors = get_q_points(mol)
    unit_vectors = [np.array(vector) for vector in unit_vectors]
    q_points.sort(key=lambda x: np.sqrt(x[0] ** 2 + x[1] ** 2 + x[2] ** 2))
    q_arrays = [np.array(point) for point in q_points]
    q_path= find_qpath(q_arrays, unit_vectors=unit_vectors)
    olm = mol.electronic_structure.OLM


    cellvectors = Geometry.getNeibouringCellVectors(cell=mol.cellvectors, m=periodic[0], n=periodic[1], l=periodic[2]) # assuming the supercell is large enough so that just the first neighbouring cells are enough; otherwise a convergence check would be needed!

    all_connected_bands = []
    first = time.time()
    bloch_states_full = bloch_form(mol)
    available_mask = np.ones(bloch_states_full.shape[1], dtype=bool)

    phi_q = []
    second = time.time()
    cel_periodic_overlap_calc(mol, path=path)
    for d in [0, 1, 2]:
        if periodic_bool[d]:
            phase = 'OLM_cell_per' + str(d + 1) + '.npy'
            phi_q.append(phase)
        else:
            phi_q.append(0)

    prim_blochs = []
    for state in prim_gam_states:
        prim_blochs.append(mol.electronic_structure.ElectronicEigenstates["alpha"][state[0]][int(state[1])].a)

    for state in prim_blochs:
        band = {}
        band[tuple(q_arrays[0])] = state
        calculated_q_points = []
        for q_index in range(0, len(q_path)):
            previous_qpoint, current_qpoint, del_q, direc = q_path[q_index][0], q_path[q_index][1], int(q_path[q_index][2]), int(q_path[q_index][3])

            if direc == +1:
                phase = np.load(path + phi_q[del_q])
            elif direc == -1:
                phase = np.conjugate(np.load(path + phi_q[del_q]).T)
            else:
                print('Some problem with the q_path calculation!', direc)

            calculated_q_points.append(previous_qpoint)
            previous_state = band[tuple(previous_qpoint)]
            third = time.time()
            if not np.any(np.all(np.isclose(np.array(calculated_q_points), current_qpoint, atol=1e-7), axis=1)):
                available_indices = np.where(available_mask)[0]

                overlaps = np.round(np.abs(np.conjugate(bloch_states_full[:, available_indices].T) @ phase @ previous_state), 6)

                # Extract the local index from the overlap array (overlaps is small)
                indices_max_local = np.where(overlaps == np.max(overlaps))[0]
                index_max_local = indices_max_local[0]
                print('max overlap',np.max(overlaps))
                # Find the global index and the state from the full array
                index_max_global = available_indices[index_max_local]
                max_state = bloch_states_full[:, index_max_global]

                # 4. Update the mask
                available_mask[index_max_global] = False

                import gc
                gc.collect()

                band[tuple(current_qpoint)] = max_state
                calculated_q_points.append(current_qpoint)


        all_connected_bands.append(band)

    return all_connected_bands

def wannierise(mol,band_index_results,path='./'):
    num_of_bands = len(band_index_results)
    num_k_points = len(list(band_index_results[0].keys()))

    k_resolved = np.array
    #for ind,band in enumerate(band_index_results):

    return None

def get_reciprocal_lattice_vectors(a1, a2, a3):
    """
    Calculate reciprocal lattice vectors from direct lattice vectors.

    Parameters:
    -----------
    a1, a2, a3 : array-like, shape (3,)
        Direct lattice vectors in real space

    Returns:
    --------
    b1, b2, b3 : numpy.ndarray, shape (3,)
        Reciprocal lattice vectors

    Notes:
    ------
    The reciprocal lattice vectors are defined by:
    b1 = 2π * (a2 × a3) / (a1 · (a2 × a3))
    b2 = 2π * (a3 × a1) / (a1 · (a2 × a3))
    b3 = 2π * (a1 × a2) / (a1 · (a2 × a3))

    The factor of 2π ensures that aᵢ · bⱼ = 2π δᵢⱼ
    """
    # Convert to numpy arrays
    a1 = np.array(a1, dtype=float)
    a2 = np.array(a2, dtype=float)
    a3 = np.array(a3, dtype=float)

    # Calculate the volume of the unit cell (scalar triple product)
    volume = np.dot(a1, np.cross(a2, a3))

    if np.abs(volume) < 1e-12:
        raise ValueError("Lattice vectors are coplanar (volume = 0). Cannot form 3D lattice.")

    # Calculate reciprocal lattice vectors
    b1 = 2 * np.pi * np.cross(a2, a3) / volume
    b2 = 2 * np.pi * np.cross(a3, a1) / volume
    b3 = 2 * np.pi * np.cross(a1, a2) / volume

    return b1, b2, b3


def symmetric_points(N, spacing=1.0):
    """
    Arrange N points symmetrically around 0 in 1D.

    Parameters:
    -----------
    N : int
        Number of points
    spacing : float
        Spacing between adjacent points

    Returns:
    --------
    points : numpy.ndarray
        1D array of symmetric points
    """
    if N % 2 == 1:
        # Odd N: include point at 0
        half_range = (N - 1) // 2
        points = np.arange(-half_range, half_range + 1) * spacing / N
    else:
        # Even N: exclude point at 0
        half_range = N // 2
        points = (np.arange(-half_range, half_range) + 0.5) * spacing / N

    return points


def trs_kpoints(coords):
    result = []
    seen = set()
    for x, y, z in coords:
        current_tuple = (x, y, z)
        negative_tuple = (-x, -y, -z)

        if current_tuple < negative_tuple:
            check_tuple = current_tuple
        else:
            check_tuple = negative_tuple

        if check_tuple not in seen:
            result.append(tuple(abs(np.array(current_tuple))))
            seen.add(check_tuple)

    return result


def incl_kpoints(N):
    klist = []
    for kx in range(-int(np.floor(N / 2)), int(np.ceil(N / 2))):
        klist.append(kx / N)
    return klist


def get_q_points(mol, return_format="combined"):
    """
    Generate k-point grid in reciprocal space for periodic systems.

    Parameters:
    -----------
    mol : molecule object
        Must have attributes: cellvectors, periodicity
    return_format : str, optional
        - 'combined': returns all k-points as single list (default)
        - 'separate': returns separate lists for each direction

    Returns:
    --------
    Depends on return_format:
    - 'combined': list of k-point vectors [k1+k2+k3 combinations]
    - 'separate': tuple (qs1, qs2, qs3) of individual direction k-points
    """

    cell_vectors = mol.cellvectors
    periodicity = mol.periodicity

    # Calculate primitive cell vectors
    primitive_cell_vectors = [cell_vectors[i] / periodicity[i] for i in range(3)]

    # Get reciprocal lattice vectors
    b1, b2, b3 = get_reciprocal_lattice_vectors(*primitive_cell_vectors)

    # Generate symmetric points for each direction
    # k1s = symmetric_points(periodicity[0])
    # k2s = symmetric_points(periodicity[1])
    # k3s = symmetric_points(periodicity[2])
    # print('old',k1s,k2s,k3s)
    # Generate q_points in fractional coordinates (more general alternative)
    k1s = incl_kpoints(periodicity[0])
    k2s = incl_kpoints(periodicity[1])
    k3s = incl_kpoints(periodicity[2])
    #print(k1s,k2s,k3s)
    #print('frac:', [k1s[0],k2s[0],k3s[0]], [k1s[1],k2s[1],k3s[1]], [k1s[2],k2s[2],k3s[2]])
    # Convert to reciprocal space coordinates with proper units
    conversion_factor = ConversionFactors["a.u.->A"]
    b = [b1, b2, b3]
    print('confactor: ', conversion_factor)
    periodic_bool = np.array(mol.periodicity) > 1
    unit_vecs = []
    for i in [0, 1, 2]:
        unit_vecs.append(tuple(np.round((b[i] * conversion_factor * periodic_bool[i]) / periodicity[i], 8)))
    print('unit_vecs: ',unit_vecs)
    # Individual direction k-points
    qs1 = [list(k1s[i] * b1 * conversion_factor) for i in range(len(k1s))]
    qs2 = [list(k2s[i] * b2 * conversion_factor) for i in range(len(k2s))]
    qs3 = [list(k3s[i] * b3 * conversion_factor) for i in range(len(k3s))]
    print(qs1,qs2,qs3)
    if return_format == 'separate':
        return qs1, qs2, qs3

    elif return_format == 'combined':
        # Return all combinations of k-points (original behavior + generalizations)
        q_points = []
        for k1 in k1s:
            for k2 in k2s:
                for k3 in k3s:
                    q_vector = np.round((k1 * b1 + k2 * b2 + k3 * b3) * conversion_factor, 8)
                    q_points.append(list(q_vector))
        return q_points, unit_vecs

    else:
        raise ValueError(f"Unknown return_format: {return_format}. "
                         "Choose from 'combined', 'separate', 'grid', or 'mesh'.")

class ElectronicState:
    def __init__(self,A=None,a=None,energy=None,symmetry_label=None,statelabel=None):
        self.A=A
        self.a=a
        self.energy=energy
        self.symmetry_label=symmetry_label
        self.state_label=None
        self.fix_phase_state()
    def fix_phase_state(self,threshold=1e-10):
        sumofvalues=np.sum(self.A)
        if sumofvalues<-threshold:
            self.A*=-1.0
            self.a*=-1.0
        elif abs(sumofvalues) <= threshold:
            # Sum is close to zero: choose a consistent phase
            # Example: align sign of max absolute value component
            max_index = np.argmax(np.abs(self.A))
            if self.A[max_index] < 0:
                self.A *= -1.0
                self.a *= -1.0
    
    
class Electronic_Symmetry(Symmetry.Symmetry):
    def __init__(self,molecular_symmetry,atoms,basis):
        super().__init__()  # Initialize parent class
        if "Id" not in molecular_symmetry.Symmetry_Generators.keys():
            generators={}
            for sym in molecular_symmetry.Symmetry_Generators:
                P=molecular_symmetry.Symmetry_Generators[sym]
                O=get_xyz_representation(symmetrylabel=sym)
                generator=get_basis_transformation(O,P,atoms,basis)
                generators[sym]=generator
            self.Symmetry_Generators=generators
            self._iscommutative()
            if self.commutative:
                self.IrrepsProjector=simultaneous_real_block_diagonalization(list(self.Symmetry_Generators.values()))
            else:
                self._determineCentralizer()
                self._determineIrrepsProjector()
        else:
            self.IrrepsProjector=np.kron(molecular_symmetry.Symmetry_Generators["Id"],np.eye(3))
        self._determineSymmetrySectors()
#### Define Symmetry Class ####
def detect_block_sizes(matrix, tol=1e-8):
        """
        Detects block sizes in a (approximately) block-diagonal square matrix.
        Args:
            matrix: (n x n) NumPy array (assumed square and block-diagonal).
            tol: threshold below which off-diagonal elements are considered zero.

        Returns:
            A list of (start_index, block_size) tuples.
        """
        n = matrix.shape[0]
        assert matrix.shape[0] == matrix.shape[1], "Matrix must be square."
        blocks = []
        i = 0

        while i < n:
            block_found = False
            for size in range(1, n - i + 1):
                # Extract candidate block
                block = matrix[i:i+size, i:i+size]

                # Check if it's isolated: off-block rows/cols should be zero
                off_block = matrix[i:i+size, i+size:]
                off_block_T = matrix[i+size:, i:i+size]

                if np.all(np.abs(off_block) < tol) and np.all(np.abs(off_block_T) < tol):
                    # Check if next row/col introduces new coupling
                    if i + size == n:
                        blocks.append((i, size))
                        i += size
                        block_found = True
                        break
                    next_col = matrix[i:i+size, i+size]
                    next_row = matrix[i+size, i:i+size]
                    if np.all(np.abs(next_col) < tol) and np.all(np.abs(next_row) < tol):
                        blocks.append((i, size))
                        i += size
                        block_found = True
                        break
            if not block_found:
                # Fallback: treat single diagonal element as a block
                blocks.append((i, 1))
                i += 1

        return blocks
def simultaneous_real_block_diagonalization(matrices):
    """
    Block-diagonalize a set of mutually commuting real matrices using a single real orthogonal basis.
    
    The matrices are assumed to commute and be real-valued. This function finds a single
    real orthogonal matrix Q that transforms every matrix A in the input list into a
    block-diagonal matrix Q.T @ A @ Q. The blocks are 1x1 for real eigenvalues
    and 2x2 for complex-conjugate eigenvalue pairs.

    Parameters:
    -----------
    matrices : list of np.ndarray
        A list of real-valued, square, mutually commuting matrices of the same shape (n x n).

    Returns:
    --------
    Q : np.ndarray
        The real orthogonal matrix (n x n) that simultaneously block-diagonalizes all matrices.

    transformed_matrices : list of np.ndarray
        The list of transformed (block-diagonal) matrices.
    """
    if not matrices:
        raise ValueError("Input list of matrices cannot be empty.")

    n = matrices[0].shape[0]
    for A in matrices:
        if A.shape != (n, n):
            raise ValueError("All matrices must be square and have the same shape.")
        # This check is good practice, though scipy.linalg.schur can handle complex inputs.
        if not np.allclose(A, A.real):
            raise ValueError("All matrices must be real-valued.")

    # 1. Create a random linear combination of the matrices.
    # Since all matrices commute, any linear combination of them also commutes with them.
    # A random combination is very likely to have distinct eigenvalues, which simplifies
    # the identification of the common eigenspaces.
    C = np.zeros((n, n))
    for A in matrices:
        C += np.random.randn() * A

    # 2. Compute the real Schur decomposition of the combined matrix C.
    # The schur function returns an orthogonal matrix Q and a block-upper-triangular
    # matrix T (the "real Schur form") such that C = Q @ T @ Q.T.
    # This matrix Q is the transformation we need.
    _, Q = schur(C, output='real')
    return Q
    
    
def get_xyz_representation(symmetrylabel):
    """
    Return the 3 × 3 Cartesian (XYZ) matrix representation of a basic
    point‑symmetry operation.

    The function currently recognises **inversion, proper rotations,
    mirror reflections** and a trivial identity operation, using the
    following label grammar:

    ──────────────────────────────────────────────────────────────────────
    Label       Meaning                               Returned matrix
    ──────────────────────────────────────────────────────────────────────
    "i"         Inversion through the origin          −I₃
    "C<axis>_<n>"
                n‑fold proper rotation about          R_axis(2π / n)
                the given axis (x, y or z)            (right‑hand rule)
    "S<axis>"   Mirror (σ) plane normal to <axis>     diag(±1, ±1, ±1)
    "t"         Identity (useful placeholder)         I₃
    ──────────────────────────────────────────────────────────────────────

    Parameters
    ----------
    symmetrylabel : str
        A string encoded as described above.
        Examples: "i", "Cx_2", "Cy_4", "Sz", "t".

    Returns
    -------
    numpy.ndarray
        A 3 × 3 `float64` NumPy array representing the operation in
        Cartesian coordinates.

    Raises
    ------
    ValueError
        If *symmetrylabel* does not conform to any of the supported
        patterns.

    Notes
    -----
    * **Right‑hand convention** – Positive rotation angles follow the
      right‑hand rule about the specified axis.
    * Rotations are constructed with ``theta = 2π / n`` (radians), so
      ``Cx_2`` is a 180 ° (π) rotation, ``Cz_4`` is a 90 ° (π/2) rotation,
      etc.
    * The mirror (“S”) labels here implement *simple* reflections, not
      roto‑reflections; extend as needed for improper rotations **Sₙ**.

    Examples
    --------
    >>> getXYZRepresentation("i")
    array([[-1.,  0.,  0.],
           [ 0., -1.,  0.],
           [ 0.,  0., -1.]])

    >>> getXYZRepresentation("Cy_4")        # 90° rotation about y
    array([[ 0. ,  0. ,  1. ],
           [ 0. ,  1. ,  0. ],
           [-1. ,  0. ,  0. ]])

    >>> getXYZRepresentation("Sz")          # mirror in xy‑plane
    array([[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0., -1.]])
    """
    if symmetrylabel=="i":
        return (-1.0)*np.eye(3)
    elif symmetrylabel[0]=="C":
        theta=2*np.pi/int(symmetrylabel.split("_")[1])
        if symmetrylabel[1]=="x":
            return np.array([[1, 0, 0],[0, np.cos(theta), -np.sin(theta)],[0, np.sin(theta),  np.cos(theta)]]).T
        elif symmetrylabel[1]=="y":
            return np.array([[np.cos(theta), 0, np.sin(theta)],[0, 1, 0],[-np.sin(theta), 0, np.cos(theta)]]).T
        elif symmetrylabel[1]=="z":
            return np.array([[np.cos(theta), -np.sin(theta), 0],[np.sin(theta),  np.cos(theta), 0],[0, 0, 1]]).T
    elif symmetrylabel[0]=="S":
        if symmetrylabel[1]=="x":
            return np.array([[-1, 0, 0],[0, 1, 0],[0, 0, 1]])
        elif symmetrylabel[1]=="y":
            return  np.array([[1, 0, 0],[0, -1, 0],[0, 0, 1]])
        elif symmetrylabel[1]=="z":
            return np.array([[1, 0, 0],[0, 1, 0],[0, 0, -1]])
    elif symmetrylabel[0]=="t":
        return np.eye(3)
def test_IrrepsProjector(name):
    el=ElectronicStructure(name)
    SymSectors = el.Electronic_Symmetry.SymSectors
    VIrr = el.Electronic_Symmetry.IrrepsProjector
    
    # 1. Sort symmetry labels alphabetically to ensure a consistent order.
    sorted_sym_labels = sorted(SymSectors.keys())
    
    # 2. Build the reordering array based on the sorted labels.
    # This groups basis functions by symmetry, in a fixed order.
    reordering = np.concatenate([SymSectors[key] for key in sorted_sym_labels])
    
    # 3. Reorder the projector matrix columns based on the sorted symmetry order.
    VIrr_reordered = VIrr[:, reordering]
    for sym in el.Electronic_Symmetry.Symmetry_Generators:
        symm=VIrr_reordered.T@el.Electronic_Symmetry.Symmetry_Generators[sym]@VIrr_reordered
        plt.imshow(symm, cmap='viridis', interpolation='nearest')
        plt.colorbar()
        plt.title(sym)
        # Save the figure
        plt.savefig("./{}.png".format(sym))
        plt.close()
